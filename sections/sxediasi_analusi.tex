\chapter{Σχεδίαση και Ανάλυση}

\section{Απαιτήσεις Συστήματος}




\subsection{Λειτουργικές απαιτήσεις}

Μια σειρά από λειτουργίες κρίθηκαν απαραίτητες και υλοποιηθήκαν στην παρούσα εφαρμογή. Έτσι:

\begin{itemize}
    \item Η εφαρμογή διαχείρισης του δικτύου θα πρέπει να  παρέχει στον χρήστη ένα γραφικό περιβάλλον που θα του επιτρέπει να αλληλεπιδρά εύκολα και αποδοτικά με το σύστημα. 
    \item Ο χρήστης θα πρέπει να έχει την δυνατότητα να παρακολουθεί την κατάσταση μιας συγκεκριμένης διεπαφής δικτύου, βλέποντας αν λειτουργεί σωστά ή αν υπάρχουν προβλήματα. 
    \item Επιπλέον, θα πρέπει να έχει τη δυνατότητα να βλέπει αναλυτικά στατιστικά στοιχεία για μια συγκεκριμένη δικτυακή συσκευή, όπως η χρήση δεδομένων, η ταχύτητα σύνδεσης ή τυχόν σφάλματα, αλλά και για συγκεκριμένες διεπαφές του δικτύου, ώστε να κατανοεί τη λειτουργία τους σε βάθος
    \item Η εφαρμογή θα επιτρέπει επίσης τη δημιουργία αντιγράφου ασφαλείας (\en{backup}) της τρέχουσας ρύθμισης του δικτύου, για να μπορεί ο χρήστης να επαναφέρει τη ρύθμιση αν χρειαστεί
    \item Τέλος, θα δίνεται η δυνατότητα αλλαγής της διεύθυνσης \en{IP} μιας επιλεγμένης δικτυακής εφαρμογής, εξασφαλίζοντας μεγαλύτερη ευελιξία στη διαχείριση του δικτύου. 
\end{itemize}

Όλες αυτές οι λειτουργίες έχουν σχεδιαστεί για να διευκολύνουν τη διαχείριση και την παρακολούθηση του δικτύου, ακόμα και από χρήστες χωρίς εξειδικευμένες γνώσεις.


\section{Αρχιτεκτονική της εφαρμογής}

Στην αρχή, οι εφαρμογές ιστού δεν ήταν τίποτα περισσότερο από ένα σύνολο αρχείων \en{HTML, CSS} και
\en{javascript} που ήταν συνδεδεμένα μεταξύ τους. Ένας καλός προγραμματιστής ήταν σε θέση να φτιάξει σπουδαίες εφαρμογές ιστού αν αυτός/αυτή
είχε αρκετές δεξιότητες/γνώσεις.

Στην εποχή μας, εμφανίστηκαν τα \en{frameworks} και λαμβάνοντας υπόψη ότι ουσιαστικά δεν βελτιώνουν αυτό που τελικά βλέπει ο χρήστης και τις
αλληλεπιδράσεις του με το \en{frontend}, τότε
θα μπορούσε κανείς να αναρωτηθεί γιατί χρησιμοποιούνται ευρέως στις μέρες μας.
Παρόμοιες δουλειές με την παρούσα εργασία υπάρχουν και σε άλλες διπλωματικές εργασίες καθώς και σε μη διπλωματικές εργασίες. Μηχανικοί από όλο τον κόσμο
ασχολούνται με την αυτοματοποίηση συστημάτων και τη δημιουργία κώδικα που να αυτοματοποιεί συσκευές/συστήματα. 

Με βάση άλλες τέτοιες προσπάθειες που έχουν γίνει στο παρελθόν εμείς συλλέξαμε την εως τώρα βιβλιογραφία
και προσπαθήσαμε να φτιάξουμε μία τέτοια εφαρμογή η οποία όμως να βασίζεται στα τωρινά δεδομένα και να 
ενσωματσώσουμε τις τελευταίες τεχνολογίες αιχμής όπως την \en{Cloud Native} αρχιτεκτονική. Στη συνέχεια γίνεται προσπάθεια να δωθεί εκτενής
ανάλυση στο πως λειτουργεί η εφαρμογή καθώς και στην αλληλλεπίδρασή της με τα συνεργαζόμενα συστήματα. 
 
\subsection{Μοντέλο \en{MVC} (\en{Model-View-Controller})}

Το μοτίβο \en{MVC}[15] (\en{Model-View-Controller} σχήμα 5.1) είναι ένα αρχιτεκτονικό πρότυπο ανάπτυξης λογισμικού που έχει ως στόχο τον διαχωρισμό της παρουσίασης των δεδομένων από τη λογική που διέπει τη διαχείριση των αλληλεπιδράσεων του χρήστη. Συγκεκριμένα, το \en{"Model"} αναλαμβάνει τη διαχείριση των δεδομένων και της επιχειρησιακής λογικής, το "\en{View}" είναι υπεύθυνο για την παρουσίαση των δεδομένων στον χρήστη, ενώ το "\en{Controller}" χειρίζεται την αλληλεπίδραση του χρήστη και τη ροή των δεδομένων μεταξύ του \en{Model} και του \en{View}.
Χάρη στη δομή του, το \en{MVC} προσφέρει μεγαλύτερη ευελιξία, επεκτασιμότητα και καλύτερη οργάνωση του κώδικα, καθιστώντας το ιδανικό για σύνθετες εφαρμογές. Γι’ αυτόν τον λόγο, όλα τα κορυφαία \en{frameworks} για την ανάπτυξη εφαρμογών \en{web}, όπως το \en{Django}, είναι βασισμένα σε αυτό το μοτίβο.


\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{graphics/MVC-Process.svg.png}
	\caption{\en{MTV} μοντέλο}
\end{figure}

\subsection{\en{Django MTV} }

Παρόλο που το \en{Django} ακολουθεί το μοτίβο \en{MVC}, προτιμά να χρησιμοποιεί τη δική του λογική στην υλοποίηση. Το \en{framework} αναλαμβάνει το \en{Controller} 
μέρος του \en{MVC} και αφήνει τα περισσότερα από τα "καλά" να γίνονται στο \en{Model-Template-View (MTV)}.
Αυτός είναι ο λόγος που το \en{Django} συχνά αναφέρεται ως \en{MTV framework}.



\subsection{Χρήση του \en{MTV} στην εφαρμογή}

Η εφαρμογή διαχείρισης δικτύου έχει υλοποιηθεί με βάση το 
αρχιτεκτονικό μοτίβο \en{MVC (Model-View-Controller)}, το οποίο 
εξασφαλίζει τη σαφή οργάνωση της λειτουργικότητας της εφαρμογής σε 
τρία επίπεδα: το μοντέλο για τη διαχείριση των δεδομένων, τα πρότυπα 
για την παρουσίαση των πληροφοριών στον χρήστη και τις προβολές για 
τη διασύνδεση των χρηστών με τα δεδομένα και την παρουσίασή τους.
Το μοντέλο αποτελεί τον πυρήνα της εφαρμογής και διαχειρίζεται τα 
δεδομένα που σχετίζονται με τις δικτυακές συσκευές. 

Το βασικό μοντέλο που χρησιμοποιείται εδώ είναι το \en{Device}, 
το οποίο αναπαριστά συσκευές όπως δρομολογητές και \en{switches}, 
αποθηκεύοντας πληροφορίες όπως η διεύθυνση του \en{host}, το όνομα 
χρήστη και ο κωδικός πρόσβασης, η πλατφόρμα της συσκευής 
και πρόσθετα στοιχεία ασφαλείας. Το \en{Device} είναι συνδεδεμένο με 
τη βάση δεδομένων της εφαρμογής και παρέχει τις βασικές λειτουργίες 
για την εισαγωγή, ανάγνωση, επεξεργασία και διαγραφή δεδομένων. 
Αυτή η δομή επιτρέπει την κεντρική διαχείριση όλων των δεδομένων που 
απαιτούνται για την ομαλή λειτουργία της εφαρμογής.

Για την παρουσίαση των δεδομένων στον χρήστη, χρησιμοποιούνται αρχεία 
\en{HTML} ως πρότυπα. Αυτά τα αρχεία λειτουργούν ως δυναμικές σελίδες 
που δημιουργούνται με τη γλώσσα \en{Django Template}, εξασφαλίζοντας 
την απεικόνιση των δεδομένων με τρόπο φιλικό προς τον χρήστη. 
Για παράδειγμα, τα πρότυπα χρησιμοποιούνται για την εμφάνιση της λίστας των συσκευών, παρέχοντας λεπτομέρειες για κάθε μία από αυτές, καθώς και για την προβολή στατιστικών ή ρυθμίσεων. Επιπλέον, τα πρότυπα προσαρμόζονται ανάλογα με τα δεδομένα που αντλούνται από το μοντέλο, ώστε να παρέχουν ενημερωμένες πληροφορίες, όπως αποτελέσματα εκτέλεσης εντολών ή την κατάσταση μιας συσκευής.

Οι προβολές της εφαρμογής είναι συναρτήσεις \en{Python} που συνδέουν 
τα αιτήματα των χρηστών με τα δεδομένα και την παρουσίαση. 
Όταν ένας χρήστης κάνει μια ενέργεια, όπως το να ζητήσει την προβολή 
μιας λίστας συσκευών, η αντίστοιχη προβολή λαμβάνει το αίτημα, 
επικοινωνεί με το μοντέλο για να ανακτήσει τα δεδομένα και στη 
συνέχεια τα περνάει στο κατάλληλο πρότυπο. 
Το πρότυπο δημιουργεί τη σελίδα \en{HTML} που θα επιστραφεί στον χρήστη, περιέχοντας όλες τις πληροφορίες που ζήτησε. Για παράδειγμα, αν ένας χρήστης θέλει να δει τα στατιστικά μιας συγκεκριμένης συσκευής, η προβολή θα αντλήσει τα απαραίτητα δεδομένα από το μοντέλο και θα τα επιστρέψει στον χρήστη μέσα από ένα προσαρμοσμένο πρότυπο.

Με τον τρόπο αυτό, το μοτίβο \en{MVC} εξασφαλίζει την αποτελεσματική 
λειτουργία της εφαρμογής, διαχωρίζοντας τις ευθύνες ανάμεσα στη 
διαχείριση των δεδομένων, την παρουσίαση τους και την επικοινωνία με τον χρήστη. Η οργάνωση αυτή καθιστά την εφαρμογή ευέλικτη και εύκολη στη συντήρηση, ενώ παράλληλα βελτιώνει την εμπειρία χρήσης, παρέχοντας ένα λειτουργικό και φιλικό περιβάλλον διαχείρισης δικτυακών συσκευών
Στο σχήμα 5.2 παρουσιάζεται διάγραμμα απεικόνισης της βασικής αρχιτεκτονικής της εφαρμογής.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{graphics/MTV.drawio.png}
	\caption{Διαγραμματική απεικόνιση της εφαρμογής}
\end{figure}



\section{Εικονικό Περιβάλλον Δικτύου \en{GNS3 –Testbed}}


Το τοπικό περιβάλλον ανάπτυξης πάνω στο οποίο δοκιµάστηκε η εφαρµογή είναι \en{Linux}, \en{Ubuntu} 22.04.2 \en{LTS} η οποία εικονοποιήθηκε πάνω σε λειτουργκό \en{Windows} ως \en{WSL2}. Το \en{Windows Subsystem for Linux version 2}[11] είναι µια τεχνολογία της \en{Microsoft} που επιτρέπει στους χρήστες \en{Windows} να τρέχουν \en{Linux} περιβάλλοντα απευθείας στο λειτουργικό σύστηµα \en{Windows}, χωρίς την ανάγκη για εξοµοιωτές ή εικονικές µηχανές. Είναι η δεύτερη έκδοση του \en{Windows Subsystem for Linux} και αποτελεί σηµαντική βελτίωση σε σχέση µε την πρώτη έκδοση \en{WSL1}. Το \en{WSL 2} χρησιµοποιεί την τεχνολογία εικονικοποίησης (\en{virtualization}) για να τρέχει έναν πραγµατικό πυρήνα \en{Linux} µέσα σε µια ελαφριά εικονική µηχανή βοηθητικών λειτουργιών (\en{utility VM}). Αυτό επιτρέπει στο \en{WSL 2} να προσφέρει καλύτερη απόδοση, πλήρη συµβατότητα µε τις λειτουργίες \en{Linux} και πρόσβαση σε εργαλεία όπως το \en{Docker}.


Το \en{WSL2} αξιοποιήθηκε διότι παρέχει τη δυνατότητα λειτουργίας ενός 
περιβάλλοντος \en{Linux} μέσα σε έναν υπολογιστή με λειτουργικό 
σύστημα \en{Windows}, χωρίς να απαιτείται η χρήση ενός \en{Type B Hypervisor}. 
Αυτό καθιστά τη διαδικασία πιο ελαφριά και αποδοτική, επιτρέποντας τη 
δημιουργία και εκτέλεση του \en{Django server} και τη διαχείριση των 
απαιτήσεων που περιλαμβάνονται στο αρχείο \en{requirements.txt} με έναν πιο οργανωμένο και σταθερό τρόπο.

Το αρχείο \en{requirements.txt}[16] είναι ένα αρχείο το οποίο περιέχει τις βιβλιοθήκες της \en{Python} που θα χρησιμοποιήσουμε στην εφαρμογή μας. Είναι ένα \en{text} αρχείο το οποίο περιέχει όλα εκείνα τα στοιχεία του λογισμικού τα οποία είναι απαραίτητα προκειμένου να τρέξει η εφαρμογή μας. Με τη βοήθεια του \en{package manager} της \en{Python} το \en{pip} μπορούμε εύκολα να εγκαταστήσουμε με μία εντολή όλες τις βιβλιοθήκες που έχουμε βάλει μέσα σε αυτό το \en{text} αρχείο. Με την εντολή αυτή \en{pip install -r requirements.txt} εγκαθιστούμε αυτόματα όλο το απαραίτητο λογισμικό προκειμένου να τρέξει η εφαρμογή μας.

Η εξοικείωσή μου με περιβάλλοντα \en{Unix} έπαιξε καθοριστικό ρόλο 
στο να επιλέξω να φτιάξω το περιβάλλον αυτό, καθώς το \en{WSL2} προσφέρει μια 
εμπειρία χρήσης που μοιάζει πολύ με αυτή ενός πλήρους \en{Linux} 
συστήματος. Αυτή η προσέγγιση επέτρεψε τη χρήση γνωστών εργαλείων και 
πρακτικών ανάπτυξης, ενώ ταυτόχρονα αξιοποίησε τη συμβατότητα του \en{Windows} 
οικοσυστήματος το οποίο χρειάστηκε για την εγκατάσταση του \en{GNS3}. Έτσι, επιτεύχθηκε η δημιουργία ενός τοπικού περιβάλλοντος 
ανάπτυξης που συνδυάζει την ευελιξία και τη σταθερότητα των \en{Unix} 
συστημάτων με την ευκολία πρόσβασης που παρέχει το λειτουργικό σύστημα \en{Windows}.

Το γεγονός ότι το \en{WSL2} αποτελεί ένα \en{Linux} περιβάλλον που εκτελείται πάνω σε λειτουργικό σύστημα \en{Windows} είχε καθοριστική σημασία για την παρούσα υλοποίηση. Αυτό οφείλεται στο ότι τόσο το \en{GNS3} όσο και το \en{VirtualBox} εγκαταστάθηκαν στο \en{Windows} περιβάλλον, ενώ το \en{WSL2} αξιοποιήθηκε αποκλειστικά για την ανάπτυξη της εφαρμογής \en{Django}. Αυτή η διάκριση στη χρήση των εργαλείων επέτρεψε την ομαλή ενσωμάτωση του \en{Linux} περιβάλλοντος στο συνολικό σύστημα, διατηρώντας παράλληλα τη συμβατότητα με τις απαιτήσεις της προσομοίωσης δικτύου.

\subsection{Σχεδίαση Τοπολογίας Δικτύου}

Η λογική την οποία χρησιμοποιήσαμε για τη δημιουργία του \en{Testbed} 
είναι ότι οι συσκευές οι οποίες τρέχουν πάνω στο \en{GNS3 VM} θα μπορέσουν
να αλληλεπιδράσουν με το τοπικό \en{WSL2} περιβάλλον. Προκειμένου να επιτευχθεί αυτός ό στόχος
ακολουθήθηκαν βήματα. Το πρώτο βήμα είναι η εγκατάσταση βασικών προγραμμάτων τα οποία έχουν παρουσιαστεί στο Θεωρητικό υπόβαθρο.

Το πως μπορούν να επικοινωνήσουν συσκευές του \en{GNS3} με το τοπικό περιβάλλον θα παρουσιαστεί σε επόμενο κεφάλαιο.Σε \en{High Level overview} η εφαρμογή ακολουθεί την παρακάτω τοπολογία:

\FloatBarrier

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.7\textwidth]{graphics/diagram.drawio.png}
	\caption{\en{Local PC-GNS3VM-CISCO IOS Connection Architecture} }
\end{figure}


\subsection{Προσομοίωση Συσκευών \en{Cisco}}

Προκειμένου να προσομειώσουμε συσκευές της \en{Cisco} το πρώτο βήμα είναι να κατεβάσουμε συγκεκριμένο \en{appliance} απο το \en{GNS3 marketplace}.
Αφού το κατεβάσουμε το εισάγουμε στο \en{GNS3} με τον εξής τρόπο: (εικόνα 5.3)

\FloatBarrier

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.7\textwidth]{graphics/import_appliance.png}
	\caption{\en{Import appliance} }
\end{figure}

Ακολούθως πατάμε \en{Install appliance on the GNS3 VM} και ματσάροντας το \en{filename} του \en{appliance} με το \en{image} που έχουμε μας επιτρέπει να εισάγουμε τη συσκευή.

Για να δούμε το \en{filename} στο \en{appliance} ανοίγουμε το αρχείο με έναν \en{editor} και αλλάζουμε το \en{filename} αντίστοιχα οπως στην  εικόνα 5.4.

\FloatBarrier

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.7\textwidth]{graphics/appliance_filename.png}
	\caption{\en{filename configuration} }
\end{figure}

\FloatBarrier

Μετά το τέλος της διαδικασίας η συσκευή θα έχει προστεθεί και μπορούμε να την δούμε στην επιλογή \en{Browse all devices}.
Συνεπώς θα μπορούμε να την προσθέσουμε σε τοπολογία και να την κάνουμε να δουλέψει.

Για να μπορέσουμε να δουλέψουμε με τη συσκευή θα πρέπει να έχουμε παραμετροποιήσει συγκεκριμένο \en{username},\en{password},\en{secret} καθώς και να τρέχει \en{ssh service}
προκειμένου να μπορούμε να συνδεθούμε μέσα απο το \en{API}. 

Στην παρακάτω εικόνα φαίνεται τι πρέπει να έχει υλοποιηθεί ως προυπόθεση στην εφαρμογή.
\FloatBarrier

\begin{figure}[htb]
	\centering
	\includegraphics[width=0.7\textwidth]{graphics/ssh.png}
	\caption{\en{ssh and credentials requirements} }
\end{figure}
