\chapter{\en{Containerization} και \en{Deployment} }

\section{\en{Containerization} με \en{Docker}}

\subsection{Δημιουργία \en{Docker Image}}

Προκειμένου να μπορέσουμε να χρησιμοποιήσουμε το \en{Docker Desktop} θα πρέπει να έχουμε φτιάξει την εφαρμογή μας σαν κοντεινερ.

Για να γίνει αυτό θα πρέπει να φτιάξουμε το παρακάτω \en{Dockerfile} το οποίο ουσιαστικά είναι η εφαρμογή μας αλλά σε κοντεινερ. 

Αυτό το \en{Dockerfile} δημιουργεί ένα περιβάλλον \en{Python 3.9} 
για ένα έργο \en{Django}. Ορίζει το φάκελο εργασίας στον κατάλογο 
\en{/app}, εγκαθιστά τις απαιτούμενες εξαρτήσεις από το αρχείο \en{requirements.txt}
, ενημερώνει το \en{pip}, και εγκαθιστά βιβλιοθήκες συστήματος 
(π.χ. \en{libyaml-dev}). 
Αντιγράφει τον κώδικα του έργου \en{Django} στο κοντέινερ, 
θέτει τη μεταβλητή περιβάλλοντος \en{PYTHONPATH}, εκθέτει την 
θύρα 8000 για τον διακομιστή \en{Django} και 
εκκινεί την εφαρμογή με την εντολή \en{runserver}.

\begin{figure}[htb]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/dockerfile.png}
	\caption{\en{Dockerfile}}
\end{figure}

\FloatBarrier


Η εντολή \en{docker build} χρησιμοποιείται για τη δημιουργία μιας εικόνας \en{Docker} (\en{Docker image}) 
από ένα συγκεκριμένο αρχείο \en{Dockerfile} και τα αρχεία που περιλαμβάνονται στον φάκελο εργασίας (\en{context}).

Αυτή η διαδικασία πακετάρει τον κώδικα της εφαρμογής, τις εξαρτήσεις και τις ρυθμίσεις σε ένα απομονωμένο περιβάλλον. 
Με αυτόν τον τρόπο, η παραγόμενη εικόνα μπορεί να διαμοιραστεί και να εκτελεστεί με συνέπεια σε διαφορετικά συστήματα, 
εξασφαλίζοντας ομοιόμορφο περιβάλλον εκτέλεσης. Είναι σημαντικό εργαλείο για αυτοματοποίηση και ανάπτυξη σε συστήματα \en{CI/CD}.

Για να φτιάξουμε το \en{image} τρέχουμε τη παρακατω εντολη. 

\FloatBarrier

\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\textwidth]{graphics/docker_build.png}
	\caption{\en{Docker build}-Δημιουργία του κοντεινερ}
\end{figure}

\FloatBarrier

Θα πρέπει μετά να βάλουμε το \en{image} στο \en{DockerDesktop} και αφού γίνει αυτό θα μπορέσουμε να την τρέξουμε στην υποδομή του κυβερνήτη.
Το ίδιο μπορεί να γίνει και χωρίς την εφαρμογή \en{DockerDesktop} αλλά τρέχοντας το \en{Docker service}
απευθείας πάνω στο \en{WSL2} όπως φαίνεται και στις παρακάτω εικόνες.

\FloatBarrier


\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/docker_image_list_2.png}
	\caption{\en{Docker image list}-}
\end{figure}

\FloatBarrier

\FloatBarrier

Παρακάτω παρουσιάζεται πως μπορούμε να κάνουμε \en{push} την εικόνα
σε αποθετήριο σε περίπτωση που θα μπορούσαμε να χρησιμοποιήσουμε το 
\en{Docker Desktop}.

\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/dockerpush.png}
	\caption{\en{Docker push}-}
\end{figure}



\section{\en{Deployment} με \en{Kubernetes}}

Τα τελευταία χρόνια, παρατηρείται ραγδαία αύξηση στον τομέα της πληροφορικής, 
με την εμφάνιση και εξάπλωση νέων εννοιών, όπως ο κυβερνήτης και τα \en{microservices}. 
Ένας βασικός παράγοντας που συνέβαλε στην εισαγωγή αυτών των τεχνολογιών είναι η ικανότητα εικονικοποίησης 
του λειτουργικού συστήματος, καθώς και η δυνατότητα εκτέλεσης εφαρμογών ως κοντέινερ. 
Αυτές οι τεχνολογίες επιτρέπουν την απομόνωση και τη διαχείριση εφαρμογών με μεγαλύτερη ευελιξία και 
αποτελεσματικότητα, κάτι που έχει οδηγήσει σε σημαντικές αλλαγές στον τρόπο ανάπτυξης και λειτουργίας των σύγχρονων υποδομών λογισμικού

Τα κοντέινερ είναι ένας καλός τρόπος για να ομαδοποιήσουμε και να εκτελέσουμε τις εφαρμογές μας. 
Σε ένα περιβάλλον παραγωγής, πρέπει να διαχειριστούμε τα κοντέινερ που εκτελούν τις εφαρμογές και να 
διασφαλίσουμε ότι δεν υπάρχει χρόνος διακοπής λειτουργίας. Για παράδειγμα, εάν ένα κοντέινερ πέσει κάτω, ένα άλλο κοντέινερ πρέπει να ξεκινήσει. 

Έτσι έρχεται να σώσει την κατάσταση ο κυβερνήτης. Το \en{Kubernetes} σάς παρέχει ένα πλαίσιο για να εκτελείτε τα κατανεμημένα συστήματα με ευελιξία. 
Φροντίζει για την κλιμάκωση και το \en{failover} για την εφαρμογή σας, παρέχει μοτίβα ανάπτυξης και πολλά άλλα. Δε θα αναλύσουμε με κάθε λεπτομέρεια
τι ακριβώς είναι ο κυβερνήτης γιατί μία τέτοια προσπάθεια είναι μία διπλωματική από μόνη της αλλά θα προσπαθήσουμε να παρουσιάσουμε τα βασικά χαρακτηριστικά τα οποία
χρησιμοποιήθηκαν πρακτικά στη διπλωματική.



Στη διπλωματική αυτή εργασία, χρησιμοποιείται ένα τοπικό περιβάλλον 
ανάπτυξης με \en{Kubernetes} μέσω του \en{Minikube} και του \en{WSL2}
(\en{Windows Subsystem for Linux} 2) για την ανάπτυξη και δοκιμή 
της εφαρμογής \en{Django}. 

Το \en{Kubernetes} είναι μια δημοφιλής 
πλατφόρμα ενορχήστρωσης κοντέινερ, που επιτρέπει την αυτόματη 
διαχείριση και κλιμάκωση εφαρμογών σε περιβάλλοντα παραγωγής, 
ενώ το \en{Minikube} προσφέρει τη δυνατότητα εκκίνησης ενός 
τοπικού \en{Kubernetes cluster}. 
Με τον τρόπο αυτό, επιτυγχάνεται η δημιουργία ενός ασφαλούς, 
απομονωμένου περιβάλλοντος δοκιμών, το οποίο προσομοιώνει ένα 
πλήρες \en{cluster}, χωρίς την ανάγκη πρόσθετης υποδομής \en{cloud}.

Χάρη στο \en{WSL2}, το οποίο επιτρέπει την εκτέλεση \en{Linux} 
πυρήνα απευθείας στα \en{Windows}, 
εξασφαλίζεται ευκολία στη διαχείριση του \en{cluster} 
και της εφαρμογής \en{Django}, 
ενώ η χρήση εργαλείων όπως το \en{kubectl} 
καθιστά εύκολη την παρακολούθηση και τον έλεγχο των \en{pods} 
και υπηρεσιών. Αυτό το περιβάλλον προσφέρει μια ολοκληρωμένη 
εμπειρία ανάπτυξης και δοκιμής, βοηθώντας στην κατανόηση των 
αρχών του \en{Kubernetes} και διευκολύνοντας τη μετάβαση της 
εφαρμογής σε μεγαλύτερα \en{production} περιβάλλοντα

Το \en{Minikube} είναι ένα εργαλείο που απλοποιεί την εκτέλεση και 
διαχείριση ενός τοπικού \en{Kubernetes cluster} στον υπολογιστή σας,
ειδικά σχεδιασμένο για περιβάλλοντα ανάπτυξης και δοκιμών. 
Σας επιτρέπει να ξεκινήσετε ένα \en{Kubernetes cluster} 
με ένα μόνο κόμβο (ή ακόμα και πολλούς σε ορισμένες περιπτώσεις) 
χρησιμοποιώντας εικονικοποίηση μέσω \en{WSL, Docker, ή Hypervisor}. 
Ο κύριος σκοπός του \en{Minikube} είναι να παρέχει ένα περιβάλλον \en{Kubernetes} 
με όλες τις βασικές δυνατότητες του \en{Kubernetes} 
αλλά χωρίς την πολυπλοκότητα που θα απαιτούσε η διαχείριση ενός \en{cluster}
σε παραγωγικό περιβάλλον.

Επιπλέον, το \en{Minikube} 
διαθέτει ενσωματωμένα εργαλεία, όπως τη δυνατότητα να παρακολουθείτε
και να διαχειρίζεστε τον πίνακα ελέγχου του \en{Kubernetes}, 
να δημιουργείτε \en{pods, deployments}, και \en{services}, και 
να παρακολουθείτε τα \en{logs} των εφαρμογών σας, ενώ επιτρέπει 
επίσης εύκολη σύνδεση με εργαλεία όπως το \en{kubectl} 
για πλήρη πρόσβαση στη διαχείριση του \en{cluster}. 
Αυτό το καθιστά ιδανικό για προγραμματιστές που θέλουν να 
πειραματιστούν με \en{Kubernetes}, 
να κάνουν δοκιμές εφαρμογών, ή να αναπτύξουν μικροϋπηρεσίες 
τοπικά χωρίς να απαιτείται η πολυπλοκότητα ενός πλήρους \en{cluster}
όπως το περιβάλλον της παρούσας διπλωματικής εργασίας. Παρακάτω μπορούμε να δούμε 
πόσο εύκολα μπορούμε να ξεκινήσουμε ένα τοπικό περιβάλλον κυβερνήτη.


\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/minikube_deployment_k8s.png}
	\caption{\en{Minikube deployment}}
\end{figure}

\subsection{Δημιουργία \en{Kubernetes manifest files}}

Στο πλαίσιο της ανάπτυξης της εφαρμογής, χρησιμοποιήθηκε το 
\en{Kubernetes} για τη δημιουργία και διαχείριση ενός \en{pod} 
που φιλοξενεί την εφαρμογή \en{Django}. Το αρχείο διαμόρφωσης \en{YAML}
(\en{pod1.yml}) που δημιουργήθηκε, ακολουθεί τη βασική δομή του \en{Kubernetes}, 
ορίζοντας τον τύπο πόρου ως \en{Pod} και 
εκχωρώντας μεταδεδομένα όπως το όνομα \en{djangotestapp}. 
Στην ενότητα \en{spec}, ορίζεται ένα \en{container} 
το οποίο χρησιμοποιεί την εικόνα \en{iasonasi/djangotestapp:latest} 
και ακούει στη θύρα 8000, η οποία είναι η προεπιλεγμένη θύρα της 
εφαρμογής \en{Django}. Παρακάτω το \en{spec} του \en{yaml file.}

\FloatBarrier

\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/pod_spec.png}
	\caption{\en{Spec}}
\end{figure}

\FloatBarrier

Αυτό το παράδειγμα αποδεικνύει τη σημασία της χρήσης του \en{Kubernetes YAML syntax} 
για την αυτοματοποιημένη ανάπτυξη και διαχείριση \en{containerized} 
εφαρμογών. Μέσω αυτής της διαδικασίας, η εφαρμογή μπορεί να 
επεκταθεί εύκολα σε διάφορα περιβάλλοντα και να κλιμακωθεί 
ανάλογα με τις ανάγκες. Το συγκεκριμένο αρχείο \en{YAML} 
επιτρέπει στο \en{Kubernetes} να εκτελέσει και να διαχειριστεί το 
\en{pod} με τρόπο ανεξάρτητο από το υποκείμενο σύστημα, 
εξασφαλίζοντας επαναληψιμότητα και δυνατότητα μεταφοράς του 
συστήματος σε διαφορετικές υποδομές. Στην παρακάτω εικόνα φαίνεται το 
\en{YAML file} που χρησιμοποιήθηκε. 

\FloatBarrier

\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/deploy_django.png}
	\caption{\en{Manifest for Django pod}}
\end{figure}

\FloatBarrier

\subsection{Πρόσβαση στο \en{Django pod}}.

Για να αποκτήσουμε πρόσβαση στην εφαρμογή \en{Django} που τρέχει στο \en{pod} του \en{Kubernetes}, 
μπορούμε να χρησιμοποιήσουμε την εντολή \en{kubectl port-forward}. 

Βρείτε το \en{pod} και με την εντολή \en{kubectl port-forward} θα μπορέσουμε μέσα απο έναν \en{browser}
να έχουμε πρόσβαση σε αυτήν.

\FloatBarrier

\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/kubernetes_proxy.png}
	\caption{\en{Port forward traffic}}
\end{figure}

\FloatBarrier

Στη συνέχεια, επισκεφτείτε την εφαρμογή σας στον \en{browser} μέσω της διεύθυνσης \en{http://localhost:8000}. Θα πρέπει όλες οι λειτουργίες
να μπορούν να εκτελεστούν κάτι το οποίο η παραπάνω εικόνα το αποδεικνύει. 


