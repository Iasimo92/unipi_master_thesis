\chapter{\en{Containerization} και \en{Deployment} }

\section{\en{Containerization} με \en{Docker}}

\subsection{Δημιουργία \en{Docker Image}}

Προκειμένου να μπορέσουμε να χρησιμοποιήσουμε το \en{Docker Desktop}, θα πρέπει να έχουμε δημιουργήσει την εφαρμογή μας σε μορφή \en{container}. Για να το πετύχουμε αυτό, είναι απαραίτητο να δημιουργήσουμε το \en{Dockerfile}(Σχήμα 8.1), το οποίο ουσιαστικά μετατρέπει την εφαρμογή μας σε \en{container}.
Προτού εξηγήσουμε τη διαδικασία δημιουργίας του \en{Image}, είναι σημαντικό να αναφέρουμε τον λόγο για τον οποίο πραγματοποιείται αυτή η διαδικασία. Οι \en{Cloud Native microservices} είναι σχεδιασμένες να λειτουργούν πάνω στην υποδομή του \en{Kubernetes}. Για να μπορέσει το \en{Kubernetes} να τις διαχειριστεί, πρέπει να γίνουν \en{deploy} σε αυτόν.
Ο \en{Kubernetes} δεν αναγνωρίζει εφαρμογές, ούτε \en{containers}, ούτε \en{Images} αλλά μόνο \en{pods}. Τα \en{pods} περιέχουν τα \en{containers}, τα οποία ουσιαστικά αποτελούν το λογισμικό που δημιουργείται μέσω της διαδικασίας δημιουργίας του \en{Image}. Ο Κυβερνήτης δεν αναγνωρίζει τίποτα άλλο εκτός από τα \en{pods}. Επειδή, λοιπόν, ο \en{Kubernetes} αναγνωρίζει \en{pods} που ορίζονται μέσω αρχείων \en{YAML}, τα οποία αναλύονται εκτενέστερα στην παράγραφο 8.2.1, δημιουργούμε το \en{Image} με τέτοιο τρόπο ώστε να μπορεί να το αναγνωρίσει ο \en{Kubernetes} στο τοπικό \en{Docker repository} και να προχωρήσει στη δημιουργία του \en{pod}.


\begin{figure}[htb]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/dockerfile.png}
	\caption{\en{Dockerfile}}
\end{figure}

\FloatBarrier


Tο \en{Dockerfile} του σχήματος 8.1 δηµιουργεί ένα περιβάλλον \en{Python 3.9} για ένα έργο \en{Django}. Ορίζει το φάκελο εργασίας στον κατάλογο \en{/app}, εγκαθιστά τις απαιτούµενες εξαρτήσεις από το αρχείο \en{requirements.txt} , ενηµερώνει το \en{pip}, και εγκαθιστά βιβλιοθήκες συστήµατος (π.χ. \en{libyaml-dev}). Αντιγράφει τον κώδικα του έργου \en{Django} στο κοντέινερ, θέτει τη µεταβλητή περιβάλλοντος \en{PYTHONPATH}, εκθέτει την θύρα 8000 για τον διακοµιστή \en{Django} και εκκινεί την εφαρµογή µε την εντολή \en{runserver}.


Η εντολή \en{docker build}(σχήμα 8.2) χρησιμοποιείται για τη δημιουργία μιας εικόνας \en{Docker} (\en{Docker image}) 
από ένα συγκεκριμένο αρχείο \en{Dockerfile} και τα αρχεία που περιλαμβάνονται στον φάκελο εργασίας (\en{context}).

Αυτή η διαδικασία πακετάρει τον κώδικα της εφαρμογής, τις εξαρτήσεις και τις ρυθμίσεις σε ένα απομονωμένο περιβάλλον. 
Με αυτόν τον τρόπο, η παραγόμενη εικόνα μπορεί να διαμοιραστεί και να εκτελεστεί με συνέπεια σε διαφορετικά συστήματα, 
εξασφαλίζοντας ομοιόμορφο περιβάλλον εκτέλεσης. Είναι σημαντικό εργαλείο για αυτοματοποίηση και ανάπτυξη σε συστήματα \en{CI/CD}. Για να φτιάξουμε το \en{image} τρέχουμε τη εντολη του σχήματος 8.2. 

\FloatBarrier

\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\textwidth]{graphics/docker_build.png}
	\caption{\en{Docker build}-Δημιουργία του κοντεινερ}
\end{figure}

\FloatBarrier

Θα πρέπει μετά να βάλουμε το \en{image} στο \en{DockerDesktop} και αφού γίνει αυτό θα μπορέσουμε να την τρέξουμε στην υποδομή του κυβερνήτη.
Το ίδιο μπορεί να γίνει και χωρίς την εφαρμογή \en{DockerDesktop} αλλά τρέχοντας το \en{Docker service}
απευθείας πάνω στο \en{WSL2} όπως φαίνεται και στην εικόνα 8.3.

\FloatBarrier


\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/docker_image_list_2.png}
	\caption{\en{Docker image list}-}
\end{figure}

\FloatBarrier



\noindent Παρακάτω παρουσιάζεται πως μπορούμε να κάνουμε \en{push} την εικόνα
σε αποθετήριο σε περίπτωση που θα μπορούσαμε να χρησιμοποιήσουμε το 
\en{Docker Desktop}.

\FloatBarrier

\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/dockerpush.png}
	\caption{\en{Docker push}-}
\end{figure}

\FloatBarrier

\section{\en{Deployment} με \en{Kubernetes}}

Τα τελευταία χρόνια, παρατηρείται ραγδαία αύξηση στον τομέα της πληροφορικής, 
με την εμφάνιση και εξάπλωση νέων εννοιών, όπως ο κυβερνήτης και τα \en{microservices}. 
Ένας βασικός παράγοντας που συνέβαλε στην εισαγωγή αυτών των τεχνολογιών είναι η ικανότητα εικονικοποίησης 
του λειτουργικού συστήματος, καθώς και η δυνατότητα εκτέλεσης εφαρμογών ως κοντέινερ. 
Αυτές οι τεχνολογίες επιτρέπουν την απομόνωση και τη διαχείριση εφαρμογών με μεγαλύτερη ευελιξία και 
αποτελεσματικότητα, κάτι που έχει οδηγήσει σε σημαντικές αλλαγές στον τρόπο ανάπτυξης και λειτουργίας των σύγχρονων υποδομών λογισμικού

Τα κοντέινερ είναι ένας καλός τρόπος για να ομαδοποιήσουμε και να εκτελέσουμε τις εφαρμογές μας. 
Σε ένα περιβάλλον παραγωγής, πρέπει να διαχειριστούμε τα κοντέινερ που εκτελούν τις εφαρμογές και να 
διασφαλίσουμε ότι δεν υπάρχει χρόνος διακοπής λειτουργίας. Για παράδειγμα, εάν ένα κοντέινερ πέσει κάτω, ένα άλλο κοντέινερ πρέπει να ξεκινήσει. 

Έτσι έρχεται να σώσει την κατάσταση ο κυβερνήτης. Το \en{Kubernetes} σάς παρέχει ένα πλαίσιο για να εκτελείτε τα κατανεμημένα συστήματα με ευελιξία. 
Φροντίζει για την κλιμάκωση και το \en{failover} για την εφαρμογή σας, παρέχει μοτίβα ανάπτυξης και πολλά άλλα. Δε θα αναλύσουμε με κάθε λεπτομέρεια
τι ακριβώς είναι ο κυβερνήτης γιατί μία τέτοια προσπάθεια είναι μία διπλωματική από μόνη της αλλά θα προσπαθήσουμε να παρουσιάσουμε τα βασικά χαρακτηριστικά τα οποία
χρησιμοποιήθηκαν πρακτικά στη διπλωματική.



Στη διπλωματική αυτή εργασία, χρησιμοποιείται ένα τοπικό περιβάλλον 
ανάπτυξης με \en{Kubernetes} μέσω του \en{Minikube} και του \en{WSL2}
(\en{Windows Subsystem for Linux} 2) για την ανάπτυξη και δοκιμή 
της εφαρμογής \en{Django}. 

Το \en{Kubernetes} είναι μια δημοφιλής 
πλατφόρμα ενορχήστρωσης κοντέινερ, που επιτρέπει την αυτόματη 
διαχείριση και κλιμάκωση εφαρμογών σε περιβάλλοντα παραγωγής, 
ενώ το \en{Minikube} προσφέρει τη δυνατότητα εκκίνησης ενός 
τοπικού \en{Kubernetes cluster}. 
Με τον τρόπο αυτό, επιτυγχάνεται η δημιουργία ενός ασφαλούς, 
απομονωμένου περιβάλλοντος δοκιμών, το οποίο προσομοιώνει ένα 
πλήρες \en{cluster}, χωρίς την ανάγκη πρόσθετης υποδομής \en{cloud}.

Χάρη στο \en{WSL2}, το οποίο επιτρέπει την εκτέλεση \en{Linux} 
πυρήνα απευθείας στα \en{Windows}, 
εξασφαλίζεται ευκολία στη διαχείριση του \en{cluster} 
και της εφαρμογής \en{Django}, 
ενώ η χρήση εργαλείων όπως το \en{kubectl} 
καθιστά εύκολη την παρακολούθηση και τον έλεγχο των \en{pods} 
και υπηρεσιών. Αυτό το περιβάλλον προσφέρει μια ολοκληρωμένη 
εμπειρία ανάπτυξης και δοκιμής, βοηθώντας στην κατανόηση των 
αρχών του \en{Kubernetes} και διευκολύνοντας τη μετάβαση της 
εφαρμογής σε μεγαλύτερα \en{production} περιβάλλοντα

Το \en{Minikube} είναι ένα εργαλείο που απλοποιεί την εκτέλεση και 
διαχείριση ενός τοπικού \en{Kubernetes cluster} στον υπολογιστή σας,
ειδικά σχεδιασμένο για περιβάλλοντα ανάπτυξης και δοκιμών. 
Σας επιτρέπει να ξεκινήσετε ένα \en{Kubernetes cluster} 
με ένα μόνο κόμβο (ή ακόμα και πολλούς σε ορισμένες περιπτώσεις) 
χρησιμοποιώντας εικονικοποίηση μέσω \en{WSL, Docker, ή Hypervisor}. 
Ο κύριος σκοπός του \en{Minikube} είναι να παρέχει ένα περιβάλλον \en{Kubernetes} 
με όλες τις βασικές δυνατότητες του \en{Kubernetes} 
αλλά χωρίς την πολυπλοκότητα που θα απαιτούσε η διαχείριση ενός \en{cluster}
σε παραγωγικό περιβάλλον.

Επιπλέον, το \en{Minikube} 
διαθέτει ενσωματωμένα εργαλεία, όπως τη δυνατότητα να παρακολουθείτε
και να διαχειρίζεστε τον πίνακα ελέγχου του \en{Kubernetes}, 
να δημιουργείτε \en{pods, deployments}[17], και \en{services}[17], και 
να παρακολουθείτε τα \en{logs} των εφαρμογών σας, ενώ επιτρέπει 
επίσης εύκολη σύνδεση με εργαλεία όπως το \en{kubectl} 
για πλήρη πρόσβαση στη διαχείριση του \en{cluster}. 
Αυτό το καθιστά ιδανικό για προγραμματιστές που θέλουν να 
πειραματιστούν με \en{Kubernetes}, 
να κάνουν δοκιμές εφαρμογών, ή να αναπτύξουν μικροϋπηρεσίες 
τοπικά χωρίς να απαιτείται η πολυπλοκότητα ενός πλήρους \en{cluster}
όπως το περιβάλλον της παρούσας διπλωματικής εργασίας. Παρακάτω μπορούμε να δούμε 
πόσο εύκολα μπορούμε να ξεκινήσουμε ένα τοπικό περιβάλλον κυβερνήτη(σχήμα 8.5).


\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/minikube_deployment_k8s.png}
	\caption{\en{Minikube deployment}}
\end{figure}

\subsection{Δημιουργία \en{Kubernetes manifest files}}

Στο πλαίσιο της ανάπτυξης της εφαρμογής, χρησιμοποιήθηκε το 
\en{Kubernetes} για τη δημιουργία και διαχείριση ενός \en{pod} 
που φιλοξενεί την εφαρμογή \en{Django}. Το αρχείο διαμόρφωσης \en{YAML}
(\en{pod1.yml}) που δημιουργήθηκε, ακολουθεί τη βασική δομή του \en{Kubernetes}, 
ορίζοντας τον τύπο πόρου ως \en{Pod} και 
εκχωρώντας μεταδεδομένα όπως το όνομα \en{djangotestapp}. 
Στην ενότητα \en{spec}, ορίζεται ένα \en{container} 
το οποίο χρησιμοποιεί την εικόνα \en{iasonasi/djangotestapp:latest} 
και ακούει στη θύρα 8000, η οποία είναι η προεπιλεγμένη θύρα της 
εφαρμογής \en{Django}. Παρακάτω το \en{spec} του \en{yaml file.}(σχήμα 8.6)

\FloatBarrier

\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/pod_spec.png}
	\caption{\en{Spec}}
\end{figure}

\FloatBarrier

Αυτό το παράδειγμα αποδεικνύει τη σημασία της χρήσης του \en{Kubernetes YAML syntax} 
για την αυτοματοποιημένη ανάπτυξη και διαχείριση \en{containerized} 
εφαρμογών. Μέσω αυτής της διαδικασίας, η εφαρμογή μπορεί να 
επεκταθεί εύκολα σε διάφορα περιβάλλοντα και να κλιμακωθεί 
ανάλογα με τις ανάγκες. Το συγκεκριμένο αρχείο \en{YAML} 
επιτρέπει στο \en{Kubernetes} να εκτελέσει και να διαχειριστεί το 
\en{pod} με τρόπο ανεξάρτητο από το υποκείμενο σύστημα, 
εξασφαλίζοντας επαναληψιμότητα και δυνατότητα μεταφοράς του 
συστήματος σε διαφορετικές υποδομές. Στην παρακάτω εικόνα φαίνεται το 
\en{YAML file} που χρησιμοποιήθηκε(σχήμα 8.7). 

\FloatBarrier

\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/deploy_django.png}
	\caption{\en{Manifest for Django pod}}
\end{figure}

\FloatBarrier

\subsection{Πρόσβαση στο \en{Django pod}}.

Για να αποκτήσουμε πρόσβαση στην εφαρμογή \en{Django} που τρέχει στο \en{pod} του \en{Kubernetes}, 
μπορούμε να χρησιμοποιήσουμε την εντολή \en{kubectl port-forward}. Βρείτε το \en{pod} και με την εντολή \en{kubectl port-forward} θα μπορέσουμε μέσα απο έναν \en{browser}
να έχουμε πρόσβαση σε αυτήν.

\FloatBarrier

\begin{figure}[h]
	\centering
	\includegraphics[width=1.5\textwidth]{graphics/kubernetes_proxy.png}
	\caption{\en{Port forward traffic}}
\end{figure}

\FloatBarrier

\noindent  Στη συνέχεια, επισκεφτείτε την εφαρμογή σας στον \en{browser} μέσω της διεύθυνσης \en{http://localhost:8000}. Θα πρέπει όλες οι λειτουργίες
να μπορούν να εκτελεστούν κάτι το οποίο η παραπάνω εικόνα το αποδεικνύει. Η διαδικασία εφαρμογής σε κυβερνήτη αποσκοπεί στην υλοποίηση της εφαρμογής ως μικροϋπηρεσία, με πολλά οφέλη. Αυτή η προσέγγιση επιτρέπει εύκολη επέκταση μέσω του \en{scaling} του κυβερνήτη και την υλοποίηση του \en{HPA} (\en{Horizontal Pod Autoscaler})[18], το οποίο αυτοματοποιεί την επέκταση της εφαρμογής προσθέτοντας περισσότερα \en{replica}. Στη συγκεκριμένη διπλωματική περιοριστήκαμε στη δημιουργία \en{pod}. Το γεγονός όμως ότι δημιουργήσαμε την μικροϋπηρεσία  μας κάνει πιο εύκολα τα οφέλη  του να  τρέχει η εφαρμογή πάνω σε υποδομή κυβερνήτη καθώς η υλοποίηση οποιουδήποτε  \en{Kubernetes} object όπως \en{HPA}  γίνεται εύκολα  με το κατάλληλο \en{YAML file}. 


